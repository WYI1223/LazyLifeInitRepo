// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:lazynote_flutter/core/bindings/frb_generated.dart';

// These functions are ignored because they are not marked as `pub`: `atom_list_failure`, `atom_type_label`, `atom_update_status_impl`, `calendar_list_by_range_impl`, `calendar_update_event_impl`, `code`, `code`, `code`, `entry_create_note_impl`, `entry_create_task_impl`, `entry_schedule_impl`, `entry_search_impl`, `failure`, `is_db_busy`, `map_db_error`, `map_note_service_error`, `map_repo_error`, `map_task_service_error`, `map_tree_repo_error`, `map_tree_service_error`, `map_workspace_db_error`, `message`, `message`, `message`, `normalize_entry_limit`, `normalize_section_limit`, `note_create_impl`, `note_failure`, `note_get_impl`, `note_set_tags_impl`, `note_update_impl`, `notes_list_impl`, `parse_entry_search_kind`, `parse_folder_delete_mode`, `parse_note_id`, `parse_optional_parent_node_id`, `parse_workspace_atom_id`, `parse_workspace_node_id`, `resolve_entry_db_path`, `set_configured_entry_db_path`, `success`, `tags_list_impl`, `tasks_list_inbox_impl`, `tasks_list_today_impl`, `tasks_list_upcoming_impl`, `to_atom_list_item`, `to_entry_search_item`, `to_note_item`, `to_workspace_node_item`, `with_atom_service`, `with_note_service`, `with_task_service`, `with_tree_service`, `workspace_create_folder_impl`, `workspace_create_note_ref_impl`, `workspace_delete_folder_impl`, `workspace_failure`, `workspace_list_children_impl`, `workspace_list_failure`, `workspace_move_node_impl`, `workspace_node_failure`, `workspace_node_kind_label`, `workspace_rename_node_impl`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `AtomFfiError`, `NotesFfiError`, `WorkspaceFfiError`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Minimal health-check API for FRB smoke integration.
///
/// # FFI contract
/// - Sync call, non-blocking.
/// - UI-thread safe for current implementation.
/// - Never throws; always returns a UTF-8 string.
String ping() => RustLib.instance.api.crateApiPing();

/// Expose core crate version through FFI.
///
/// # FFI contract
/// - Sync call, non-blocking.
/// - UI-thread safe for current implementation.
/// - Never throws; always returns a UTF-8 string.
String coreVersion() => RustLib.instance.api.crateApiCoreVersion();

/// Initializes Rust core logging once per process.
///
/// Input semantics:
/// - `level`: one of `trace|debug|info|warn|error` (case-insensitive).
/// - `log_dir`: absolute directory path where rolling logs are written.
///
/// # FFI contract
/// - Sync call; may perform small file-system setup work.
/// - Safe to call repeatedly with the same `level + log_dir` (idempotent).
/// - Reconfiguration attempts with different level or directory return error.
/// - Never panics; returns empty string on success and error message on failure.
String initLogging({required String level, required String logDir}) =>
    RustLib.instance.api.crateApiInitLogging(level: level, logDir: logDir);

/// Configures a process-local default SQLite path for entry APIs.
///
/// # FFI contract
/// - Sync call, non-blocking.
/// - Safe to call multiple times; latest successful path wins.
/// - Returns empty string on success, error message on validation/IO failure.
String configureEntryDbPath({required String dbPath}) =>
    RustLib.instance.api.crateApiConfigureEntryDbPath(dbPath: dbPath);

/// Searches single-entry text using entry-level defaults.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - Never panics.
/// - Returns deterministic envelope with applied limit.
Future<EntrySearchResponse> entrySearch({
  required String text,
  String? kind,
  int? limit,
}) => RustLib.instance.api.crateApiEntrySearch(
  text: text,
  kind: kind,
  limit: limit,
);

/// Creates a note from single-entry command flow.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - Never panics.
/// - Returns operation result and created atom ID on success.
Future<EntryActionResponse> entryCreateNote({required String content}) =>
    RustLib.instance.api.crateApiEntryCreateNote(content: content);

/// Creates a task from single-entry command flow.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - Never panics.
/// - Returns operation result and created atom ID on success.
Future<EntryActionResponse> entryCreateTask({required String content}) =>
    RustLib.instance.api.crateApiEntryCreateTask(content: content);

/// Schedules an event from single-entry command flow.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - Accepts point (`end_epoch_ms=None`) and range (`Some(end)`) shapes.
/// - Never panics.
/// - Returns operation result and created atom ID on success.
Future<EntryActionResponse> entrySchedule({
  required String title,
  required PlatformInt64 startEpochMs,
  PlatformInt64? endEpochMs,
}) => RustLib.instance.api.crateApiEntrySchedule(
  title: title,
  startEpochMs: startEpochMs,
  endEpochMs: endEpochMs,
);

/// Creates one note from markdown content.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - Applies markdown preview hooks (`preview_text`, `preview_image`).
/// - Returns typed envelope with stable error codes.
Future<NoteResponse> noteCreate({required String content}) =>
    RustLib.instance.api.crateApiNoteCreate(content: content);

/// Fully replaces note content by stable id.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - `content` is treated as full markdown source replacement.
/// - Returns typed envelope with stable error codes.
Future<NoteResponse> noteUpdate({
  required String atomId,
  required String content,
}) => RustLib.instance.api.crateApiNoteUpdate(atomId: atomId, content: content);

/// Gets one note by stable id.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - Returns typed envelope with stable error codes.
Future<NoteResponse> noteGet({required String atomId}) =>
    RustLib.instance.api.crateApiNoteGet(atomId: atomId);

/// Lists notes with optional single-tag filter and pagination.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - Returns only `AtomType::Note` rows.
/// - Limit normalization: default 10, max 50.
Future<NotesListResponse> notesList({String? tag, int? limit, int? offset}) =>
    RustLib.instance.api.crateApiNotesList(
      tag: tag,
      limit: limit,
      offset: offset,
    );

/// Atomically replaces full tag set for one note.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - `tags` is treated as complete replacement, not incremental patch.
/// - Returns typed envelope with stable error codes.
Future<NoteResponse> noteSetTags({
  required String atomId,
  required List<String> tags,
}) => RustLib.instance.api.crateApiNoteSetTags(atomId: atomId, tags: tags);

/// Lists normalized tags known by storage.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - Returns typed envelope with stable error codes.
Future<TagsListResponse> tagsList() => RustLib.instance.api.crateApiTagsList();

/// Lists workspace child nodes under optional parent.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - `parent_node_id` is optional UUID string; `None` lists root-level nodes.
Future<WorkspaceListChildrenResponse> workspaceListChildren({
  String? parentNodeId,
}) => RustLib.instance.api.crateApiWorkspaceListChildren(
  parentNodeId: parentNodeId,
);

/// Creates one workspace folder under optional parent.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - `parent_node_id` is optional UUID string; `None` creates root-level folder.
Future<WorkspaceNodeResponse> workspaceCreateFolder({
  String? parentNodeId,
  required String name,
}) => RustLib.instance.api.crateApiWorkspaceCreateFolder(
  parentNodeId: parentNodeId,
  name: name,
);

/// Creates one workspace note_ref under optional parent.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - `atom_id` must be UUID string of a note atom.
Future<WorkspaceNodeResponse> workspaceCreateNoteRef({
  String? parentNodeId,
  required String atomId,
  String? displayName,
}) => RustLib.instance.api.crateApiWorkspaceCreateNoteRef(
  parentNodeId: parentNodeId,
  atomId: atomId,
  displayName: displayName,
);

/// Renames one workspace node.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - `node_id` must be UUID string.
Future<WorkspaceActionResponse> workspaceRenameNode({
  required String nodeId,
  required String newName,
}) => RustLib.instance.api.crateApiWorkspaceRenameNode(
  nodeId: nodeId,
  newName: newName,
);

/// Moves one workspace node under optional new parent and target order.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - `new_parent_id = None` moves node to root level.
Future<WorkspaceActionResponse> workspaceMoveNode({
  required String nodeId,
  String? newParentId,
  PlatformInt64? targetOrder,
}) => RustLib.instance.api.crateApiWorkspaceMoveNode(
  nodeId: nodeId,
  newParentId: newParentId,
  targetOrder: targetOrder,
);

/// Deletes one workspace folder by explicit mode (`dissolve|delete_all`).
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - `node_id` must be UUID string of a folder node.
/// - `mode` must be one of `dissolve` or `delete_all`.
Future<WorkspaceActionResponse> workspaceDeleteFolder({
  required String nodeId,
  required String mode,
}) => RustLib.instance.api.crateApiWorkspaceDeleteFolder(
  nodeId: nodeId,
  mode: mode,
);

/// Lists inbox atoms (both `start_at` and `end_at` NULL).
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - Excludes done/cancelled atoms.
Future<AtomListResponse> tasksListInbox({int? limit, int? offset}) =>
    RustLib.instance.api.crateApiTasksListInbox(limit: limit, offset: offset);

/// Lists atoms active today based on time-matrix rules.
///
/// # FFI contract
/// - `bod_ms`/`eod_ms`: device-local day boundaries in epoch ms.
/// - Async call, DB-backed execution.
/// - Excludes done/cancelled atoms.
Future<AtomListResponse> tasksListToday({
  required PlatformInt64 bodMs,
  required PlatformInt64 eodMs,
  int? limit,
  int? offset,
}) => RustLib.instance.api.crateApiTasksListToday(
  bodMs: bodMs,
  eodMs: eodMs,
  limit: limit,
  offset: offset,
);

/// Lists atoms anchored entirely in the future.
///
/// # FFI contract
/// - `eod_ms`: end of today in epoch ms.
/// - Async call, DB-backed execution.
/// - Excludes done/cancelled atoms.
Future<AtomListResponse> tasksListUpcoming({
  required PlatformInt64 eodMs,
  int? limit,
  int? offset,
}) => RustLib.instance.api.crateApiTasksListUpcoming(
  eodMs: eodMs,
  limit: limit,
  offset: offset,
);

/// Updates `task_status` for any atom type (universal completion).
///
/// # FFI contract
/// - `status`: one of `todo|in_progress|done|cancelled`, or null to clear (demote).
/// - Async call, DB-backed execution.
/// - Idempotent: setting the same status twice succeeds.
Future<EntryActionResponse> atomUpdateStatus({
  required String atomId,
  String? status,
}) => RustLib.instance.api.crateApiAtomUpdateStatus(
  atomId: atomId,
  status: status,
);

/// Lists atoms with both `start_at` and `end_at` that overlap the given time range.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - Includes all statuses (done/cancelled shown on calendar).
/// - Range overlap: `start_at < range_end AND end_at > range_start`.
Future<AtomListResponse> calendarListByRange({
  required PlatformInt64 startMs,
  required PlatformInt64 endMs,
  int? limit,
  int? offset,
}) => RustLib.instance.api.crateApiCalendarListByRange(
  startMs: startMs,
  endMs: endMs,
  limit: limit,
  offset: offset,
);

/// Updates only `start_at` and `end_at` for a calendar event.
///
/// # FFI contract
/// - Async call, DB-backed execution.
/// - Validates `end_ms >= start_ms`; returns `invalid_time_range` on failure.
/// - Returns `atom_not_found` when target atom does not exist.
Future<EntryActionResponse> calendarUpdateEvent({
  required String atomId,
  required PlatformInt64 startMs,
  required PlatformInt64 endMs,
}) => RustLib.instance.api.crateApiCalendarUpdateEvent(
  atomId: atomId,
  startMs: startMs,
  endMs: endMs,
);

/// Atom list item returned by section queries (Inbox/Today/Upcoming).
class AtomListItem {
  /// Stable atom ID in string form.
  final String atomId;

  /// Atom projection kind (`note|task|event`).
  final String kind;

  /// Raw markdown content.
  final String content;

  /// Derived plain-text preview.
  final String? previewText;

  /// Derived first markdown image path.
  final String? previewImage;

  /// Normalized lowercase tags for this atom.
  final List<String> tags;

  /// Epoch ms — start boundary (NULL = no start).
  final PlatformInt64? startAt;

  /// Epoch ms — end boundary (NULL = no end).
  final PlatformInt64? endAt;

  /// Current task status string, or null if statusless.
  final String? taskStatus;

  /// Update timestamp in epoch milliseconds.
  final PlatformInt64 updatedAt;

  const AtomListItem({
    required this.atomId,
    required this.kind,
    required this.content,
    this.previewText,
    this.previewImage,
    required this.tags,
    this.startAt,
    this.endAt,
    this.taskStatus,
    required this.updatedAt,
  });

  @override
  int get hashCode =>
      atomId.hashCode ^
      kind.hashCode ^
      content.hashCode ^
      previewText.hashCode ^
      previewImage.hashCode ^
      tags.hashCode ^
      startAt.hashCode ^
      endAt.hashCode ^
      taskStatus.hashCode ^
      updatedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AtomListItem &&
          runtimeType == other.runtimeType &&
          atomId == other.atomId &&
          kind == other.kind &&
          content == other.content &&
          previewText == other.previewText &&
          previewImage == other.previewImage &&
          tags == other.tags &&
          startAt == other.startAt &&
          endAt == other.endAt &&
          taskStatus == other.taskStatus &&
          updatedAt == other.updatedAt;
}

/// Section list response envelope.
class AtomListResponse {
  /// Whether operation succeeded.
  final bool ok;

  /// Stable machine-readable error code for failure paths.
  final String? errorCode;

  /// Human-readable message for diagnostics/UI.
  final String message;

  /// Section items.
  final List<AtomListItem> items;

  /// Effective limit after normalization.
  final int appliedLimit;

  const AtomListResponse({
    required this.ok,
    this.errorCode,
    required this.message,
    required this.items,
    required this.appliedLimit,
  });

  @override
  int get hashCode =>
      ok.hashCode ^
      errorCode.hashCode ^
      message.hashCode ^
      items.hashCode ^
      appliedLimit.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AtomListResponse &&
          runtimeType == other.runtimeType &&
          ok == other.ok &&
          errorCode == other.errorCode &&
          message == other.message &&
          items == other.items &&
          appliedLimit == other.appliedLimit;
}

/// Generic action response envelope for single-entry command flow.
class EntryActionResponse {
  /// Whether operation succeeded.
  final bool ok;

  /// Optional created atom ID.
  final String? atomId;

  /// Human-readable response message for diagnostics/UI.
  final String message;

  const EntryActionResponse({
    required this.ok,
    this.atomId,
    required this.message,
  });

  @override
  int get hashCode => ok.hashCode ^ atomId.hashCode ^ message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EntryActionResponse &&
          runtimeType == other.runtimeType &&
          ok == other.ok &&
          atomId == other.atomId &&
          message == other.message;
}

/// Search item returned by single-entry search API.
class EntrySearchItem {
  /// Stable atom ID in string form.
  final String atomId;

  /// Atom projection kind (`note|task|event`).
  final String kind;

  /// Short snippet summary for result display.
  final String snippet;

  const EntrySearchItem({
    required this.atomId,
    required this.kind,
    required this.snippet,
  });

  @override
  int get hashCode => atomId.hashCode ^ kind.hashCode ^ snippet.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EntrySearchItem &&
          runtimeType == other.runtimeType &&
          atomId == other.atomId &&
          kind == other.kind &&
          snippet == other.snippet;
}

/// Search response envelope for single-entry search flow.
class EntrySearchResponse {
  /// Whether search execution succeeded.
  final bool ok;

  /// Optional stable error code for machine branching.
  final String? errorCode;

  /// Search results (empty when no hits or scaffold mode).
  final List<EntrySearchItem> items;

  /// Human-readable response message for diagnostics.
  final String message;

  /// Effective applied search limit.
  final int appliedLimit;

  const EntrySearchResponse({
    required this.ok,
    this.errorCode,
    required this.items,
    required this.message,
    required this.appliedLimit,
  });

  @override
  int get hashCode =>
      ok.hashCode ^
      errorCode.hashCode ^
      items.hashCode ^
      message.hashCode ^
      appliedLimit.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EntrySearchResponse &&
          runtimeType == other.runtimeType &&
          ok == other.ok &&
          errorCode == other.errorCode &&
          items == other.items &&
          message == other.message &&
          appliedLimit == other.appliedLimit;
}

/// Note DTO returned by notes/tags APIs.
class NoteItem {
  /// Stable note atom id.
  final String atomId;

  /// Raw markdown content.
  final String content;

  /// Derived plain-text preview.
  final String? previewText;

  /// Derived first markdown image path.
  final String? previewImage;

  /// Update timestamp in epoch milliseconds.
  final PlatformInt64 updatedAt;

  /// Normalized tags attached to the note.
  final List<String> tags;

  const NoteItem({
    required this.atomId,
    required this.content,
    this.previewText,
    this.previewImage,
    required this.updatedAt,
    required this.tags,
  });

  @override
  int get hashCode =>
      atomId.hashCode ^
      content.hashCode ^
      previewText.hashCode ^
      previewImage.hashCode ^
      updatedAt.hashCode ^
      tags.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NoteItem &&
          runtimeType == other.runtimeType &&
          atomId == other.atomId &&
          content == other.content &&
          previewText == other.previewText &&
          previewImage == other.previewImage &&
          updatedAt == other.updatedAt &&
          tags == other.tags;
}

/// Note create/update/get response envelope.
class NoteResponse {
  /// Whether operation succeeded.
  final bool ok;

  /// Stable machine-readable error code for failure paths.
  final String? errorCode;

  /// Human-readable message for diagnostics/UI.
  final String message;

  /// Returned note payload on success.
  final NoteItem? note;

  const NoteResponse({
    required this.ok,
    this.errorCode,
    required this.message,
    this.note,
  });

  @override
  int get hashCode =>
      ok.hashCode ^ errorCode.hashCode ^ message.hashCode ^ note.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NoteResponse &&
          runtimeType == other.runtimeType &&
          ok == other.ok &&
          errorCode == other.errorCode &&
          message == other.message &&
          note == other.note;
}

/// Note list response envelope.
class NotesListResponse {
  /// Whether operation succeeded.
  final bool ok;

  /// Stable machine-readable error code for failure paths.
  final String? errorCode;

  /// Human-readable message for diagnostics/UI.
  final String message;

  /// Note list items sorted by `updated_at DESC, uuid ASC`.
  final List<NoteItem> items;

  /// Effective limit after normalization.
  final int appliedLimit;

  const NotesListResponse({
    required this.ok,
    this.errorCode,
    required this.message,
    required this.items,
    required this.appliedLimit,
  });

  @override
  int get hashCode =>
      ok.hashCode ^
      errorCode.hashCode ^
      message.hashCode ^
      items.hashCode ^
      appliedLimit.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NotesListResponse &&
          runtimeType == other.runtimeType &&
          ok == other.ok &&
          errorCode == other.errorCode &&
          message == other.message &&
          items == other.items &&
          appliedLimit == other.appliedLimit;
}

/// Tags list response envelope.
class TagsListResponse {
  /// Whether operation succeeded.
  final bool ok;

  /// Stable machine-readable error code for failure paths.
  final String? errorCode;

  /// Human-readable message for diagnostics/UI.
  final String message;

  /// Normalized tags known by storage.
  final List<String> tags;

  const TagsListResponse({
    required this.ok,
    this.errorCode,
    required this.message,
    required this.tags,
  });

  @override
  int get hashCode =>
      ok.hashCode ^ errorCode.hashCode ^ message.hashCode ^ tags.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TagsListResponse &&
          runtimeType == other.runtimeType &&
          ok == other.ok &&
          errorCode == other.errorCode &&
          message == other.message &&
          tags == other.tags;
}

/// Workspace action response envelope.
class WorkspaceActionResponse {
  /// Whether operation succeeded.
  final bool ok;

  /// Stable machine-readable error code for failure paths.
  final String? errorCode;

  /// Human-readable message for diagnostics/UI.
  final String message;

  const WorkspaceActionResponse({
    required this.ok,
    this.errorCode,
    required this.message,
  });

  @override
  int get hashCode => ok.hashCode ^ errorCode.hashCode ^ message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WorkspaceActionResponse &&
          runtimeType == other.runtimeType &&
          ok == other.ok &&
          errorCode == other.errorCode &&
          message == other.message;
}

/// Workspace children-list response envelope.
class WorkspaceListChildrenResponse {
  /// Whether operation succeeded.
  final bool ok;

  /// Stable machine-readable error code for failure paths.
  final String? errorCode;

  /// Human-readable message for diagnostics/UI.
  final String message;

  /// Child nodes in deterministic order.
  final List<WorkspaceNodeItem> items;

  const WorkspaceListChildrenResponse({
    required this.ok,
    this.errorCode,
    required this.message,
    required this.items,
  });

  @override
  int get hashCode =>
      ok.hashCode ^ errorCode.hashCode ^ message.hashCode ^ items.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WorkspaceListChildrenResponse &&
          runtimeType == other.runtimeType &&
          ok == other.ok &&
          errorCode == other.errorCode &&
          message == other.message &&
          items == other.items;
}

/// Workspace tree node DTO exposed over FFI.
class WorkspaceNodeItem {
  /// Stable workspace node id.
  final String nodeId;

  /// Node kind label (`folder|note_ref`).
  final String kind;

  /// Parent node id for non-root nodes.
  final String? parentNodeId;

  /// Target note atom id for note_ref nodes.
  final String? atomId;

  /// User-facing display name.
  final String displayName;

  /// Deterministic sibling order key.
  final PlatformInt64 sortOrder;

  const WorkspaceNodeItem({
    required this.nodeId,
    required this.kind,
    this.parentNodeId,
    this.atomId,
    required this.displayName,
    required this.sortOrder,
  });

  @override
  int get hashCode =>
      nodeId.hashCode ^
      kind.hashCode ^
      parentNodeId.hashCode ^
      atomId.hashCode ^
      displayName.hashCode ^
      sortOrder.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WorkspaceNodeItem &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          kind == other.kind &&
          parentNodeId == other.parentNodeId &&
          atomId == other.atomId &&
          displayName == other.displayName &&
          sortOrder == other.sortOrder;
}

/// Workspace single-node response envelope.
class WorkspaceNodeResponse {
  /// Whether operation succeeded.
  final bool ok;

  /// Stable machine-readable error code for failure paths.
  final String? errorCode;

  /// Human-readable message for diagnostics/UI.
  final String message;

  /// Returned node payload on success.
  final WorkspaceNodeItem? node;

  const WorkspaceNodeResponse({
    required this.ok,
    this.errorCode,
    required this.message,
    this.node,
  });

  @override
  int get hashCode =>
      ok.hashCode ^ errorCode.hashCode ^ message.hashCode ^ node.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WorkspaceNodeResponse &&
          runtimeType == other.runtimeType &&
          ok == other.ok &&
          errorCode == other.errorCode &&
          message == other.message &&
          node == other.node;
}
